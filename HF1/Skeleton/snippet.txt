
class Strip {

public: std::vector<vec2> points;	//control points
public:	int nVertices = 0;
private: std::vector<float> ts;		//knots

public: void init() {
	glGenVertexArrays(1, &vao);	// get 1 vao id
	glBindVertexArray(vao);		// make it active

	unsigned int vbo;		// vertex buffer object
	glGenBuffers(1, &vbo);	// Generate 1 buffer
	glBindBuffer(GL_ARRAY_BUFFER, vbo);

	/**
	glBufferData(GL_ARRAY_BUFFER, 	// Copy to GPU target
		points.size() * sizeof(vec2),  // # bytes
		&points[0],	      	// address
		GL_DYNAMIC_DRAW);	// we do not change later


	glEnableVertexAttribArray(0);  // AttribArray 0
	glVertexAttribPointer(0,       // vbo -> AttribArray 0
		2, GL_FLOAT, GL_FALSE, // two floats/attrib, not fixed-point
		0, NULL); 		     // stride, offset: tightly packed
		*/
}

		void addPoint(vec2 p) {
			points.push_back(p);
			nVertices = points.size();
			ts.push_back(points.size()); //ti
		}
		void addPoints(std::vector<vec2>& p) {
			points = p;
			nVertices = points.size();
		}
		void removeLast() {
			points.pop_back();
			nVertices = points.size();
		}

		void draw() {
			glBufferData(GL_ARRAY_BUFFER, 	// Copy to GPU target
				points.size() * sizeof(vec2),  // # bytes
				&points[0],	      	// address
				GL_DYNAMIC_DRAW);	// we do not change later

			glEnableVertexAttribArray(0);  // AttribArray 0
			glVertexAttribPointer(0,       // vbo -> AttribArray 0
				2, GL_FLOAT, GL_FALSE, // two floats/attrib, not fixed-point
				0, NULL); 		     // stride, offset: tightly packed

			// Set color to (0, 1, 0) = green
			int location = glGetUniformLocation(gpuProgram.getId(), "color");
			glUniform3f(location, 1.0f, 1.0f, 1.0f); // 3 floats

			float MVPtransf[4][4] = { 1, 0, 0, 0,    // MVP matrix, 
									  0, 1, 0, 0,    // row-major!
									  0, 0, 1, 0,
									  0, 0, 0, 1 };

			location = glGetUniformLocation(gpuProgram.getId(), "MVP");	// Get the GPU location of uniform variable MVP
			glUniformMatrix4fv(location, 1, GL_TRUE, &MVPtransf[0][0]);	// Load a 4x4 row-major float matrix to the specified location

			glBindVertexArray(vao);  // Draw call
			glDrawArrays(GL_LINE_STRIP, 0 /*startIdx*/, nVertices /*# Elements*/);
		}

		float L(int i, float t) {
			float Li = 1.0f;
			for (int j = 0; j < points.size(); j++) {
				if (j != i) {
					Li *= (t - ts[j]) / (ts[i] - ts[j]);
				}
			}
			return Li;
		}
		vec2 r(float t) {
			vec2 rr(0, 0);
			for (int i = 0; i < points.size(); i++) {
				rr.x += points[i].x * L(i, t);
				rr.y += points[i].y * L(i, t);
			}
			return rr;
		}
		void drawLagr() {
			std::vector<vec2> rt;
			for (float t = -10.0f; t < 10.0f; t += 0.1f) {
				vec2 tmp = r(t);
				rt.push_back(tmp);
				printf("t:%f (%f,%f)\n", t, tmp.x, tmp.y);
			}

			glBufferData(GL_ARRAY_BUFFER, 	// Copy to GPU target
				rt.size() * sizeof(vec2),  // # bytes
				&rt[0],	      	// address
				GL_DYNAMIC_DRAW);	// we do not change later

			glEnableVertexAttribArray(0);  // AttribArray 0
			glVertexAttribPointer(0,       // vbo -> AttribArray 0
				2, GL_FLOAT, GL_FALSE, // two floats/attrib, not fixed-point
				0, NULL); 		     // stride, offset: tightly packed

			// Set color
			int location = glGetUniformLocation(gpuProgram.getId(), "color");
			glUniform3f(location, 1.0f, 1.0f, 1.0f); // 3 floats

			float MVPtransf[4][4] = { 1, 0, 0, 0,    // MVP matrix, 
									  0, 1, 0, 0,    // row-major!
									  0, 0, 1, 0,
									  0, 0, 0, 1 };

			location = glGetUniformLocation(gpuProgram.getId(), "MVP");	// Get the GPU location of uniform variable MVP
			glUniformMatrix4fv(location, 1, GL_TRUE, &MVPtransf[0][0]);	// Load a 4x4 row-major float matrix to the specified location

			glBindVertexArray(vao);  // Draw call
			glDrawArrays(GL_LINE_STRIP, 0 /*startIdx*/, rt.size() /*# Elements*/);
		}
};
class Hermite {
	//public: std::vector<vec2> points;	//control points
	vec2 p0;
	vec2 v0;
	float t0 = 0.0f;
	vec2 p1;
	vec2 v1;
	float t1 = 1.0f;

public:
	void init() {
		p0 = vec2(-0.5f, -0.5f);
		v0 = vec2(0.0, 4.0);
		p1 = vec2(0.5, 0.5);
		v1 = vec2(1.0, 0.0);
		//printf("(%f,%f)\n", p0.x, p0.y);
		glGenVertexArrays(1, &vao);	// get 1 vao id
		glBindVertexArray(vao);		// make it active

		unsigned int vbo;		// vertex buffer object
		glGenBuffers(1, &vbo);	// Generate 1 buffer
		glBindBuffer(GL_ARRAY_BUFFER, vbo);
	}

	vec2 div(vec2 a, vec2 b) {
		//printf("div: (%f,%f)/(%f,%f)\n", a.x, a.y, b.x, b.y);
		return vec2(a.x / b.x, a.y / b.y);
	}
	vec2 r(float t) {
		vec2 a2 = ((p1 - p0) * 3) * (1.0f / ((t1 - t0)*(t1 - t0))) - (v1 + v0 * 2) * (1.0f / (t1 - t0));
		vec2 a3 = ((p0 - p1) * 2) * (1.0f / ((t1 - t0)*(t1 - t0)*(t1 - t0))) + (v1 + v0) * (1.0f / ((t1 - t0)*(t1 - t0)));
		float tt = (t - t0);
		printf("a2: (%f,%f)\n", a2.x, a2.y);
		printf("a3: (%f,%f)\n", a3.x, a3.y);
		return a3 * (tt*tt*tt) + a2 * (tt*tt) + v0 * tt + p0;
	}

	void draw() {
		std::vector<vec2> rt;



		for (float t = 0.0f; t < 1.0f; t += 0.05f) {
			vec2 tmp = r(t);
			rt.push_back(tmp);
			printf("t:%f (%f,%f)\n", t, tmp.x, tmp.y);
		}


		glBufferData(GL_ARRAY_BUFFER, 	// Copy to GPU target
			rt.size() * sizeof(vec2),  // # bytes
			&rt[0],	      	// address
			GL_DYNAMIC_DRAW);	// we do not change later
		glEnableVertexAttribArray(0);  // AttribArray 0
		glVertexAttribPointer(0,       // vbo -> AttribArray 0
			2, GL_FLOAT, GL_FALSE, // two floats/attrib, not fixed-point
			0, NULL); 		     // stride, offset: tightly packed
		// Set color
		int location = glGetUniformLocation(gpuProgram.getId(), "color");
		glUniform3f(location, 1.0f, 1.0f, 1.0f); // 3 floats
		float MVPtransf[4][4] = { 1, 0, 0, 0,    // MVP matrix, 
								  0, 1, 0, 0,    // row-major!
								  0, 0, 1, 0,
								  0, 0, 0, 1 };

		location = glGetUniformLocation(gpuProgram.getId(), "MVP");	// Get the GPU location of uniform variable MVP
		glUniformMatrix4fv(location, 1, GL_TRUE, &MVPtransf[0][0]);	// Load a 4x4 row-major float matrix to the specified location
		glBindVertexArray(vao);  // Draw call
		glDrawArrays(GL_LINE_STRIP, 0 /*startIdx*/, rt.size() /*# Elements*/);
	}


};